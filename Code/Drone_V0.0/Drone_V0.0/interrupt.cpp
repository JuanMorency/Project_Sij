#include "interrupt.h"

volatile bool flagESC = 0;
volatile bool flagWS2812 = 0;
volatile bool flagIMU = 0;
volatile bool flagAK8963 = 0;
volatile bool flagBMP180 = 0;

XYZ16_TypeDef currentRawAcc;
XYZ16_TypeDef currentRawGyr; 
XYZ16_TypeDef currentRawMag; 

volatile unsigned long timer0_overflow_count = 0;
float deltat = 0.0f;        // integration interval for both filter schemes
uint8_t lastUpdate = 0; // used to calculate integration interval
uint8_t Now = 0;        // used to calculate integration interval

uint8_t lastRead = MPU9255_READ;
volatile bool I2CInterruptBusy = false;

/*
PCINT0 is unused
PCINT1 is used for RF controller
*/

/**
	* @brief Sets the registers for timer 0 for interrupt control and starts interrupts
    * @param none
	* @retval None
	*/
void startInterrupt(IMU &imu1)
{
	/* by setting the max count of the counter (OCR0A) and the prescaler (with TCCR0B), the frequency of the interrupts
	generated by the counter can be controlled with precision */
	OCR0A = 0xFF;	/*Sets the maximum value of the counter before going back to 0*/
	TCCR0B |= (1 << CS01); /*prescaler 001 = 1, 010 = 8, 011 = 64, 100 = 256, 101 = 1024*/
	TCCR0A |= (1 << WGM01); /*Sets the mode of the counter to CTC to clear counter once OCR0A is reached*/
	TIMSK0 |= (1 << OCIE0A)|(1 << TOIE0); /*enable interrupt when counter reaches OCR0A*/
	
	////Use INT2 to use the interrupts generated by the IMU. Might be too fast since it is at 1kHz. Deactivated for now. 
	//EICRA |= (1<<ISC20)|(1<<ISC21); /* Sets the rising edge of INT2 to trigger interrupts */
	//EIMSK |= (1<<INT2);	/* Enables INT2 */
	phys_adress = MPU9255_ADDRESS<<1;
	data_adress = MPU9255_RA_ACCEL_XOUT_H;
	data_length = 14;
	startI2CForFsm();
	sei();	/* Turn interrupts on */

}


/**
	* @brief ISR for reading the pwm from the radio receiver. 
	*/
ISR(PCINT1_vect) {
	if(RFInitialized)
	{
		handleFSMRF();
					
		if (RFserialSlowDownCounter >= RF_SERIAL_SPEED_DIVIDER)
		{
			RFserialSlowDownCounter = 0;
			sprintf(buffer, "1:%u 2:%u 3:%u 4:%u \n", ch_1_pw, ch_2_pw, ch_3_pw, ch_4_pw);
			serialTransmit(buffer);
		}
		else
		{
			RFserialSlowDownCounter++;
		}
	}
}

/**
	* @brief ISR for reading the interrupt generated by the IMU
    * @param none
	* @retval None
	*/
ISR(INT2_vect) {
	if(InertMUInitialized)
	{
		flagIMU = true;
	}
}

///**
	//* @brief ISR for the overflow on the counter (may not be necessary)
    //* @param none
	//* @retval None
	//*/
//ISR(TIMER3_OVF_vect) {
	//timer_3_ovf=true;
	//TIFR3 &= ~(1 << TOV3);
//}


ISR(TIMER0_OVF_vect){
	timer0_overflow_count++;
}

/**
	* @brief ISR for the event counter. This sets the different flags at different frequencies 
	in order to control different hardware. This is where to add different flags if you want more interrupt
	routines
    * @param none
	* @retval None
	*/
ISR(TIMER0_COMPA_vect){	
	static unsigned int ESCFlagCount;
	static unsigned int WS2812FlagCount;
	static unsigned int IMUFlagCount;
	static unsigned int AK8963FlagCount;
	static unsigned int BMP180FlagCount;

	if(escInitialized == true){
		if(ESCFlagCount >= ESC_PERIOD){
			flagESC = true;
			ESCFlagCount = 0;
		}
		else {
			ESCFlagCount++;
		}
	}

	if(WS2812Initialized == true){
		if(WS2812FlagCount >= WS2812_PERIOD){
			flagWS2812 = true;
			WS2812FlagCount = 0;
		}
		else {
			WS2812FlagCount++;
		}
	}

	if(InertMUInitialized == true){
		if(IMUFlagCount >= IMU_PERIOD){
			flagIMU = true;
			IMUFlagCount = 0;
		}
		else {
			IMUFlagCount++;
		}
	}

	if(AK8963Initialized == true){
		if(AK8963FlagCount >= AK8963_PERIOD){
			flagAK8963 = true;
			AK8963FlagCount = 0;
		}
		else {
			AK8963FlagCount++;
		}
	}
	
	if(BMP180Initialized == true){
		if(BMP180FlagCount >= BMP180_PERIOD){
			flagBMP180 = true;
			BMP180FlagCount = 0;
		}
		else {
			BMP180FlagCount++;
		}
	}
}


/**
	* @brief ISR for reading the interrupt generated by the USART 
    * @param none
	* @retval None
	*/
ISR(USART0_RX_vect) {
	if(serialInitialized)
	{
		serialReceive();
	}
}

/**
	* @brief ISR for reading the interrupt generated by the USART
    * @param none
	* @retval None
	*/
ISR(USART0_TX_vect) {
	if(serialInitialized)
	{
		serialTransmitINT();
	}
}

ISR(TWI_vect) {
	if(TwiInterruptInitialized)
	{
		if(handleFsmI2c() == 0) // I2C read has completed successfully
		{
			I2CInterruptBusy = false;
			
			// Update the current values in the interrupt buffers
			switch(lastRead)
			{
				case MPU9255_READ:
					currentRawAcc.X = (dataReadBuffer[0] << 8) | dataReadBuffer[1];
					currentRawAcc.Y = (dataReadBuffer[2] << 8) | dataReadBuffer[3];
					currentRawAcc.Z = (dataReadBuffer[4] << 8) | dataReadBuffer[5];
					currentRawGyr.X = (dataReadBuffer[8] << 8) | dataReadBuffer[9];
					currentRawGyr.Y = (dataReadBuffer[10] << 8) | dataReadBuffer[11];
					currentRawGyr.Z = (dataReadBuffer[12] << 8) | dataReadBuffer[13];
					break;
				case AK8963_READ:
					currentRawMag.X = (dataReadBuffer[1] << 8) | dataReadBuffer[0];
					currentRawMag.Y = (dataReadBuffer[3] << 8) | dataReadBuffer[2];
					currentRawMag.Z = (dataReadBuffer[5] << 8) | dataReadBuffer[4];				
					break;
				default:
					lastRead = MPU9255_READ;
					break;
			}
			
			// Put the right address for the next read depending on flags
			// default is MPU9255 and AK8963 happen at the frequency
			// set in interrupt.h
			if(flagAK8963)
			{
				flagAK8963 = false;
				lastRead = AK8963_READ;
				phys_adress = AK8963_ADDRESS<<1;
				data_adress = AK8963_RA_HXL;
				data_length = 7;
				// Send start condition
				TWCR = 0;
				TWCR = (1<<TWINT)|(1<<TWIE)|(1<<TWSTA)|(1<<TWEN);
			}
			else if(flagBMP180)
			{
				flagBMP180 = false;
				//CalculateTemperaturePressureAndAltitude();
				// Send start condition
				TWCR = 0;
				TWCR = (1<<TWINT)|(1<<TWIE)|(1<<TWSTA)|(1<<TWEN);
				turnDebugLedOn(7);
			}
			else
			{
				lastRead = MPU9255_READ;	
				phys_adress = MPU9255_ADDRESS<<1;
				data_adress = MPU9255_RA_ACCEL_XOUT_H;
				data_length = 14;
				// Send start condition
				TWCR = 0;
				TWCR = (1<<TWINT)|(1<<TWIE)|(1<<TWSTA)|(1<<TWEN);			
			}

		}
		else
		{
			I2CInterruptBusy = true;
		}
	}
}