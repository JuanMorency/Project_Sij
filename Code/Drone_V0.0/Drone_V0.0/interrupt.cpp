#include "interrupt.h"

volatile bool flagESC = 0;
volatile bool flagWS2812 = 0;
volatile bool flagIMU = 0;

volatile unsigned long timer0_overflow_count = 0;
float deltat = 0.0f;        // integration interval for both filter schemes
uint8_t lastUpdate = 0; // used to calculate integration interval
uint8_t Now = 0;        // used to calculate integration interval

/*
PCINT0 is unused
PCINT1 is used for RF controller
*/

/**
	* @brief Sets the registers for timer 0 for interrupt control and starts interrupts
    * @param none
	* @retval None
	*/
void startInterrupt()
{
	/*by setting the max count of the counter (OCR0A) and the prescaler (with TCCR0B), the frequency of the interrupts
	generated by the counter can be controlled with precision */
	OCR0A = 0xFF;	/*Sets the maximum value of the counter before going back to 0*/
	TCCR0B |= (1 << CS01); /*prescaler 001 = 1, 010 = 8, 011 = 64, 100 = 256, 101 = 1024*/
	TCCR0A |= (1 << WGM01); /*Sets the mode of the counter to CTC to clear counter once OCR0A is reached*/
	TIMSK0 |= (1 << OCIE0A)|(1 << TOIE0); /*enable interrupt when counter reaches OCR0A*/
	
	////Use INT2 for the using the interrupts generated by the IMU. Might be too fast since it is at 1kHz. Deactivated for now. 
	//EICRA |= (1<<ISC20)|(1<<ISC21); /* Sets the rising edge of INT2 to trigger interrupts */
	//EIMSK |= (1<<INT2);	/* Enables INT2 */
	
	sei();	/* Turn interrupts on */
}


/**
	* @brief ISR for reading the pwm from the radio receiver. 
	*/
ISR(PCINT1_vect) {
	if(RFInitialized)
	{
		handleFSMRF();
					
		if (RFserialSlowDownCounter >= RF_SERIAL_SPEED_DIVIDER)
		{
			RFserialSlowDownCounter = 0;
			sprintf(buffer, "1:%u 2:%u 3:%u 4:%u \n", ch_1_pw, ch_2_pw, ch_3_pw, ch_4_pw);
			serialTransmit(buffer);
		}
		else
		{
			RFserialSlowDownCounter++;
		}
	}
}

/**
	* @brief ISR for reading the interrupt generated by the IMU
    * @param none
	* @retval None
	*/
ISR(INT2_vect) {
	if(InertMUInitialized)
	{
		flagIMU = true;
	}
}

///**
	//* @brief ISR for the overflow on the counter (may not be necessary)
    //* @param none
	//* @retval None
	//*/
//ISR(TIMER3_OVF_vect) {
	//timer_3_ovf=true;
	//TIFR3 &= ~(1 << TOV3);
//}


ISR(TIMER0_OVF_vect){
	timer0_overflow_count++;
}

/**
	* @brief ISR for the event counter. This sets the different flags at different frequencies 
	in order to control different hardware. This is where to add different flags if you want more interrupt
	routines
    * @param none
	* @retval None
	*/
ISR(TIMER0_COMPA_vect){	
	static unsigned int ESCFlagCount;
	static unsigned int WS2812FlagCount;
	static unsigned int IMUFlagCount;

	if(escInitialized == true){	
		if(ESCFlagCount >= ESC_PERIOD){
			flagESC = true;
			ESCFlagCount = 0;
		}
		else {
			ESCFlagCount++;
		}
	}

	if(WS2812Initialized == true){
		if(WS2812FlagCount >= WS2812_PERIOD){
			flagWS2812 = true;
			WS2812FlagCount = 0;
		}
		else {
			WS2812FlagCount++;
		}
	}

	if(InertMUInitialized == true){
		if(IMUFlagCount >= IMU_PERIOD){
			flagIMU = true;
			IMUFlagCount = 0;
		}
		else {
			IMUFlagCount++;
		}
	}
}


/**
	* @brief ISR for reading the interrupt generated by the USART 
    * @param none
	* @retval None
	*/
ISR(USART0_RX_vect) {
	if(serialInitialized)
	{
		serialReceive();
	}
}

/**
	* @brief ISR for reading the interrupt generated by the USART
    * @param none
	* @retval None
	*/
ISR(USART0_TX_vect) {
	if(serialInitialized)
	{
		serialTransmitINT();
	}
}